/********************************************************************************
 * Copyright (C) 2017-2020 German Aerospace Center (DLR). 
 * Eclipse ADORe, Automated Driving Open Research https://eclipse.org/adore
 *
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0 
 *
 * Contributors: 
 *   Reza Dariani - initial API and implementation
 ********************************************************************************/

#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include "adore/mad/arraymatrixtools.h"
#include "adore/mad/cubicpiecewisefunctionstatic.h"

TEST_CASE( "testing fit function", "[cubic piecewice function]" ) {
    int const static NumOfPoints = 51;
    double noise [NumOfPoints] = {-0.000998835001955834,0.0548548779596420,0.159684716546092,0.438267087542479,0.493865579572692,0.673707025643806,0.723880546039734,0.787071435810957,0.907407367797499,0.980629833385455,1.04883883951107,0.882391725800078,1.07111444663088,1.02054002232507,1.08027729187045,0.956592530162842,0.900731729508063,0.904597446606405,0.716081829916998,0.684165964167967,0.667955749998874,0.496685917927753,0.437160189695485,0.296417945563935,0.142530640729599,-0.0506530948028049,-0.0920499901004103,-0.331993324444330,-0.342932595650361,-0.449564762512247,-0.541834881229029,-0.606396682663624,-0.674052598199068,-0.790522108434836,-0.888537754890940,-0.865393903832316,-0.966269177577000,-1.09463014076082,-1.07385481420856,-0.909745106988755,-0.954197214052733,-0.835855917550767,-0.902446908697828,-0.760054974468035,-0.658570428915805,-0.681387049139960,-0.458810990278287,-0.395642260230067,-0.338783371356443,-0.127419235728840,-0.0614979207875853};
    double solution[NumOfPoints] = { 0.141148185521340,0.360290337195951,0.578065918266799,0.791930813869470,0.998223814464165,1.19310583857154,1.37272778880520,1.53361977511784,1.67262299655552,1.78685735711605,1.87402354704761,1.93261519999952,1.96183259578393,1.96082499589883,1.92929602410278,1.86757312612187,1.77681837612513,1.65862024673826,1.51489178286135,1.34802448742804,1.16040696200124,0.954625972695487,0.733831641875318,0.501520755794914,0.261657378492027,0.0185389639478135,-0.223538064420688,-0.460627076196945,-0.688999234120169,-0.905582045253962,-1.10761261532166,-1.29252253596337,-1.45789181581706,-1.60130359431637,-1.72031278449107,-1.81273083198422,-1.87680505510871,-1.91099402066724,-1.91438123373836,-1.88731479653173,-1.83122283067761,-1.74786472252063,-1.63938835055835,-1.50814359264664,-1.35706875308634,-1.18934441014736,-1.00821258928750,-0.817229793921996,-0.619629431427537,-0.418229962817249};
    auto x = adore::mad::CubicPiecewiseFunction::BreaksGenerator(0.,2*M_PI, NumOfPoints);
    double y_noisy [NumOfPoints];
    double w[NumOfPoints];
    double p = 0.8;
    for(int i=0; i<NumOfPoints; i++) 
    {
        w[i]= 1.;
        y_noisy[i] = std::sin(x[i]) + noise[i];
    }    
    adore::mad::CubicPiecewiseFunction::PieceweisePolynomial pp;
    adore::mad::CubicPiecewiseFunction::fit(&pp,x.data(),y_noisy,w,NumOfPoints,p);
    REQUIRE((adore::mad::ArrayMatrixTools::sum(solution,NumOfPoints)/NumOfPoints - adore::mad::ArrayMatrixTools::sum(pp.coef_4,NumOfPoints)/NumOfPoints) < 1e-8);
}

TEST_CASE( "testing static fit function", "[cubicpiecewisefunctionstatic]" ) {
    int const static NumOfPoints = 51;
    adore::mad::CubicPiecewiseFunctionStatic<NumOfPoints> cpfs;
    double noise [NumOfPoints] = {-0.000998835001955834,0.0548548779596420,0.159684716546092,0.438267087542479,0.493865579572692,0.673707025643806,0.723880546039734,0.787071435810957,0.907407367797499,0.980629833385455,1.04883883951107,0.882391725800078,1.07111444663088,1.02054002232507,1.08027729187045,0.956592530162842,0.900731729508063,0.904597446606405,0.716081829916998,0.684165964167967,0.667955749998874,0.496685917927753,0.437160189695485,0.296417945563935,0.142530640729599,-0.0506530948028049,-0.0920499901004103,-0.331993324444330,-0.342932595650361,-0.449564762512247,-0.541834881229029,-0.606396682663624,-0.674052598199068,-0.790522108434836,-0.888537754890940,-0.865393903832316,-0.966269177577000,-1.09463014076082,-1.07385481420856,-0.909745106988755,-0.954197214052733,-0.835855917550767,-0.902446908697828,-0.760054974468035,-0.658570428915805,-0.681387049139960,-0.458810990278287,-0.395642260230067,-0.338783371356443,-0.127419235728840,-0.0614979207875853};
    double solution[NumOfPoints] = { 0.141148185521340,0.360290337195951,0.578065918266799,0.791930813869470,0.998223814464165,1.19310583857154,1.37272778880520,1.53361977511784,1.67262299655552,1.78685735711605,1.87402354704761,1.93261519999952,1.96183259578393,1.96082499589883,1.92929602410278,1.86757312612187,1.77681837612513,1.65862024673826,1.51489178286135,1.34802448742804,1.16040696200124,0.954625972695487,0.733831641875318,0.501520755794914,0.261657378492027,0.0185389639478135,-0.223538064420688,-0.460627076196945,-0.688999234120169,-0.905582045253962,-1.10761261532166,-1.29252253596337,-1.45789181581706,-1.60130359431637,-1.72031278449107,-1.81273083198422,-1.87680505510871,-1.91099402066724,-1.91438123373836,-1.88731479653173,-1.83122283067761,-1.74786472252063,-1.63938835055835,-1.50814359264664,-1.35706875308634,-1.18934441014736,-1.00821258928750,-0.817229793921996,-0.619629431427537,-0.418229962817249};
    auto x = adore::mad::CubicPiecewiseFunction::BreaksGenerator(0.,2*M_PI, NumOfPoints);
    double y_noisy [NumOfPoints];
    double w[NumOfPoints];
    double p = 0.8;
    for(int i=0; i<NumOfPoints; i++) 
    {
        w[i]= 1.;
        y_noisy[i] = std::sin(x[i]) + noise[i];
    }    
    cpfs.fit(x.data(),y_noisy,w,p);
    REQUIRE((adore::mad::ArrayMatrixTools::sum(solution,NumOfPoints)/NumOfPoints - adore::mad::ArrayMatrixTools::sum(cpfs.coef_4,NumOfPoints-1)/(NumOfPoints-1)) < 1e-8);

}